## 时间复杂度和空间复杂度

- 时间：执行当前算法所消耗的时间
- 空间：执行当前算法所需要占用多少内存空间

- 时间复杂度：渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系
- 空间复杂度：渐进空间复杂度，表示算法的存储空间与数据模型之间的增长关系

算法的执行效率由**执行时间、存储空间**两方面决定。**复杂度分析就是用来分析算法执行效率与数据规模之间的关系**，包括**时间复杂度**和**空间复杂度**。

## 大 O 表示法
$T(n) = O(f(n))$

**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**

- T(n)：代码执行的时间
- n：数据规模
- f(n)：每行代码执行的次数总和
- O：表示 T(n) 与 f(n) 成正比

### 常见的时间复杂度
按数量级递增如下：  
- 常量阶 $O(1)$
- 对数阶 $O(logn)$(2为底，即$O(log_2n)$)
- 线性阶 $O(n)$
- 线性对数阶 $O(nlogn)$(2为底，即$O(nlog_2n)$)
- 平方阶 $O(n^2)$
- 立方阶 $O(n^3)$
- 指数阶 $O(2^n)$
- 阶乘阶 $O(n!)$

其中，**指数阶**和**阶乘阶**会随着数据规模`n`的增大，执行时间急剧增长，十分低效，暂且不去分析。

#### 常量阶 O(1)
```js
const a = 1;
let b = 2;
```
上述代码，执行时消耗的时间不受某个变量`n`的增长而影响，所以它的时间复杂度为$O(1)$。也就是说，一般情况下除了循环语句、递归语句，时间复杂度都为$O(1)$。

#### 对数阶 O(logn)
```js
let i = 1;
const n = 6;
while(i < n) {
  i *= 2;
}
```
上述代码，当循环x次后，循环退出。也就是$2^x=n$，那么$x=log_2n$，也就是循环$log_2n$次循环退出，得出时间复杂度为$O(logn)$  

**二分查找的时间复杂度就是$O(logn)$**

#### 线性阶O(n)
```js
const n = 996;
for(let i = 0; i <= n; i++) {
  console.log(i);
}
```
for循环里的代码会执行n遍，所以这类代码的时间复杂度就是$O(n)$。

**计数排序、基数排序、桶排序的时间复杂度都是$O(n)$**

#### 线性对数阶O(nlogn)
```js
let j = 1;
const n = 6;
for(let i = 0; i <= n; i++) {
  while (j < i) {
    j *= 2;
  }
}
```
上述代码，就是将时间复杂度为$O(logn)$的代码循环n遍，那么它的时间复杂度就是$O(nlogn)$。

**归并排序、快速排序、堆排序的时间复杂度都是$O(nlogn)$**

#### 平方阶O(n^2)
```js
const n = 6;
for(let i = 0; i <= n; i++) {
  for(let j = 0; j <= n; i++) {
    console.log('nacho');
  }
}
```
平方阶就是把$O(n)$的代码再嵌套一层循环，它的时间复杂度就是$O(n^2)$了。

**冒泡排序、插入排序、选择排序的时间复杂度都是$O(n^2)$**

立方阶$O(n^3)$就是在$O(n^2)$的基础上再嵌套一层循环。

### 小结

采用大 O 表示法进行复杂度分析的时候，是可以忽略系数的，一般情况下只需要关注循环执行次数最多的一段代码进行分析即可。

除此之外，**还有最好其情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度以及均摊时间复杂度等**。在实际中，大多数情况下并不是特别常用。

在现实中，往往代码会比较复杂，总结几条判断时间复杂度的小技巧：  
- 单段代码看高频：循环
- 多段代码取最大：有循环和多重循环的情况，取多重循环的复杂度
- 嵌套代码求乘积：循环中的递归
- 多个规模求和：分别有两个参数控制两个循环的次数，取二者的复杂度相加

### 常见的空间复杂度
- $O(1)$
- $O(n)$
- $O(n^2)$

#### O(1)
```js
const a = 1;
let b = 2;
```
定义的变量a、b所占用的空间并不会随着某个变量的变化而变化，所以它的空间复杂度为$O(1)$

#### O(n)
```js
let arr = [];
const n = 996;
for(let i = 0; i <= n; i++) {
  arr[i] = i;
}
```
arr所占用的内存由n来决定，会随着n的增大而增大，，所以它的空间复杂度就是$O(n)$。如果初始化一个二维数组$n*n$，那么它的空间复杂度就是$O(n^2)$

除此之外，$O(logn)$、$O(nlogn)$这样的对数阶空间复杂度在平时也很少见。

一般在实际中，空间复杂度和初始化的数组长度有关。除此之外，也和递归的深度有关。

### 时空转换
时间复杂度和空间复杂度往往是相互影响的，两者不可兼得。根据实际情况，常用的做法就是空间换时间。比如：记忆化搜索、缓存等。