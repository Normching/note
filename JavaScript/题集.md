1. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。  
  - A: 对
  - B: 错
  - C: 看情况

答案：A  

解析：基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。

****
2. 输出是什么？
   ```js
   const obj = { 1: 'a', 2: 'b', 3: 'c' }
   const set = new Set([1, 2, 3, 4, 5])

   obj.hasOwnProperty('1')
   obj.hasOwnProperty(1)
   set.has('1')
   set.has(1)
   ```
  - A：`false true false true`
  - B：`false true true true`
  - C：`true true false true`
  - D：`true true true true`

答案：C  

解析：所有对象的键（不包括symbol）在底层都是字符串，即使没有将其作为字符串输入。`obj.hasOwnProperty('1')`也返回`true`

对于集合，则不是。在集合中没有`'1'`，`set.has('1')`返回`true`。它的数字类型为`1`，`set.has(1)`返回`true`。

****
3. 输出是什么？
  ```js
  var num = 8;
  var num = 10;

  console.log(num);
  ```
  - A: 8
  - B: 10
  - C: SyntaxError
  - D: ReferenceError
  
  答案：B

  解析：使用 `var` 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。

****
4. 输出是什么？
  ```js
  function getPersonInfo(one, two, three) {
    console.log(one)
    console.log(two)
    console.log(three)
  }

  const person = 'Lydia'
  const age = 21

  getPersonInfo`${person} is ${age} years old`
  ```
  - A: "Lydia" 21 ["", " is ", " years old"]
  - B: ["", " is ", " years old"] "Lydia" 21
  - C: "Lydia" ["", " is ", " years old"] 21
  
  答案：B

  解析：如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值。

5. 输出是什么
   ```js
   const a = {}
   const b = { key: 'b' }
   const c = { key: 'c' }

   a[b] = 123
   a[c] = 456

   console.log(a[b])
   ```
   - A: 123
   - B: 456
   - C: undefined
   - D: ReferenceError
   
   答案：B

   解析：对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。
然而，当字符串化一个对象时，它会变成 `"[object Object]"`。因此这里说的是，`a["[object Object]"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a["[object Object]"] = 456`。
然后，我们打印 `a[b]`，也就是 `a["[object Object]"]`。之前刚设置为 `456`，因此返回的是 `456`。

6. 输出是什么
  ```js
  ['1','2','3'].map(parseInt)
  ```
  答案： `[1, NaN, NaN]`  
  解析：  
  map函数的第一个参数callback，这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。  
  `arr.map(callback: (value: T, index: number, array: T[]) => U, thisArg?: any);`  
  parseInt是用来解析字符串的，使字符串称为指定基数的整数。接收两个参数，第一个参数表示被处理的值（字符串），第二个表示为解析时的基数。  
  `parseInt('1', 0)` 基数radix为0时，且string参数不以`0x`或`0`开头时，按照10位基数处理，此时 返回`1`  
  `parseInt('2', 1)` 基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回`NaN`  
  `parseInt('3', 2)` 基数为2（2进制）表示的数中，最小值小于3，所以无法解析，返回`NaN`

7. 防抖和节流
  防抖——触发高频时间后n秒后函数只会执行一次，如果n秒内高频时间再次触发，则重新计时
  ```js
  function debounce(fn) {
    let timeout = null; // 创建一个标记来存放定时器的返回值
    
    return function() {
      clearTimeout(timeout); // 每当用户输入的时候 把前一个 setTimeout clear掉
      timeout = setTimeout(() => {
        // 然后又创建一个新的 setTimeout ,这样能够保证输入字符后的interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
        fn.apply(this, arguments)
      }, 500);      
    }
  }
  ```  
  
  节流——高频时间触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率  
  ```js
  function throttle(fn) {
    let canRun = true // 通过闭包保存一个标记
    return function() {
      if(!canRun) return
      canRun = false // 立即设置为 false
      setTimeout(()=> {
        // 将外部传入的函数的执行放在setTimeout 中
        fn.apply(this, arguments)
        // 最后在 setTimeout 执行完毕后再把标记设置为 true（关键）表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return 掉
        canRun = true
      }, 500)
    }
  }
  ```

8. 介绍下Set、Map、WeakSet和WeakMap的区别
   答案：  
   - Set —— 对象允许存储任何类型的唯一值，无论是原始值或者是对象引用
   - WeakSet —— 成员都是都是对象：成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏；
   - Map —— 本质上是键值对的集合，类似集合；可以遍历，方法很多，可以跟各种数据格式转换。
   - WeakMap —— 只能接收对象作为键名（null除外），不接受其他类型的值作为键名；键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；不能遍历，方法有get、set、has、delete。

9. 深度优先遍历和广度优先遍历
  深度优先遍历 —— 是指从某个顶点出发，首先访问这个节点，然后找出刚访问这个节点的第一个未被访问的子结点，然后再以此子结点为顶点，继续找到它的下一个结点进行访问。重复此步骤，知道所有结点都被访问完为止；
  广度优先遍历 —— 是指从某个顶点出发，首先访问这个顶点，然后找到刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个字结点的所有结点，重复此方法，直到所有结点都被访问完为止。
  ```js
  // 1.深度优先遍历的递归写法
  function deepTraversal(node) {
    let nodes = []
    if(nodes != null) {
      let childrens = node.children
      for(let i = 0; i < childrens.length; i++) {
        deepTraversal(childrens[i])
      }
    }
    return nodes
  }

  // 2. 深度优先遍历的非递归写法
  function deepTraversal(node) {
    let nodes = []
    if(nodes != null) {
      let stack = [] // 用来存放将来要访问的节点
      stack.push(node)
      while(stack.length != 0) {
        let item = stack.pop() // 正在访问的节点
        nodes.push(item)
        let childrens = item.children
        for(let i = childrens.length - 1; i >= 0; i--) {
          stack.push(childrens[i]) // 将现在访问的节点的子节点存入stack，供将来访问
        }
      }
    }
    return nodes
  }

  // 3. 广度优先遍历的递归写法
  function wideTraversal(node) {
    let nodes = [],
        i = 0
    if(node != null) {
      nodes.push(node)
      wideTraversal(node.nextElementSibling)
      node = nodes[i++]
      wideTraversal(node.firstElementSibling)
    }
    return nodes
  }

  // 4. 广度优先遍历的非递归写法
  function wideTraversal(node) {
    let nodes = [],
        i = 0
    while(node != null) {
      nodes.push(node)
      node = nodes[i++]
      let childrens = node.children
      for(let i = 0; i < childrens.length; i++) {
        nodes.push(childrens[i])
      }
    }
    return nodes
  }
  ```

10. 输出是什么
  ```js
  (() => {
    let x,y
    try {
      throw new Error()
    } catch(x) {
      (x = 1), (y = 2)
      console.log(x)
    }
    console.log(x)
    console.log(y)
  })()
  ```
  答案：  
  `1 undefined 2`  
  解析：  
  `catch`代码块接收参数`x`。当我们传递参数时，这与之前定义的变量`x`不同，这个`x`属于`catch`块作用域。  
  然后，将块作用域中的变量`x`赋值为`1`，同时也设置了变量`y`的值。  
  `catch`块之外的变量`x`的值仍然为`undefined`，`y`的值为`2`。当在`catch`块之外执行`console.log(x)`时，返回`undefined`，`y`返回`2`。