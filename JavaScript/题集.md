1. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。  
  - A: 对
  - B: 错
  - C: 看情况

答案：A  

解析：基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。

****
2. 输出是什么？
   ```js
   const obj = { 1: 'a', 2: 'b', 3: 'c' }
   const set = new Set([1, 2, 3, 4, 5])

   obj.hasOwnProperty('1')
   obj.hasOwnProperty(1)
   set.has('1')
   set.has(1)
   ```
  - A：`false true false true`
  - B：`false true true true`
  - C：`true true false true`
  - D：`true true true true`

答案：C  

解析：所有对象的键（不包括symbol）在底层都是字符串，即使没有将其作为字符串输入。`obj.hasOwnProperty('1')`也返回`true`

对于集合，则不是。在集合中没有`'1'`，`set.has('1')`返回`true`。它的数字类型为`1`，`set.has(1)`返回`true`。

****
3. 输出是什么？
  ```js
  var num = 8;
  var num = 10;

  console.log(num);
  ```
  - A: 8
  - B: 10
  - C: SyntaxError
  - D: ReferenceError

  答案：B

  解析：使用 `var` 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。

****
4. 输出是什么？
  ```js
  function getPersonInfo(one, two, three) {
    console.log(one)
    console.log(two)
    console.log(three)
  }

  const person = 'Lydia'
  const age = 21

  getPersonInfo`${person} is ${age} years old`
  ```
  - A: "Lydia" 21 ["", " is ", " years old"]
  - B: ["", " is ", " years old"] "Lydia" 21
  - C: "Lydia" ["", " is ", " years old"] 21

  答案：B

  解析：如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值。

5. 输出是什么
   ```js
   const a = {}
   const b = { key: 'b' }
   const c = { key: 'c' }

   a[b] = 123
   a[c] = 456

   console.log(a[b])
   ```
   - A: 123
   - B: 456
   - C: undefined
   - D: ReferenceError
   
   答案：B

   解析：对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。
然而，当字符串化一个对象时，它会变成 `"[object Object]"`。因此这里说的是，`a["[object Object]"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a["[object Object]"] = 456`。
然后，我们打印 `a[b]`，也就是 `a["[object Object]"]`。之前刚设置为 `456`，因此返回的是 `456`。

6. 输出是什么
  ```js
  ['1','2','3'].map(parseInt)
  ```
  答案： `[1, NaN, NaN]`  
  解析：  
  map函数的第一个参数callback，这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。  
  `arr.map(callback: (value: T, index: number, array: T[]) => U, thisArg?: any);`  
  parseInt是用来解析字符串的，使字符串称为指定基数的整数。接收两个参数，第一个参数表示被处理的值（字符串），第二个表示为解析时的基数。  
  `parseInt('1', 0)` 基数radix为0时，且string参数不以`0x`或`0`开头时，按照10位基数处理，此时 返回`1`  
  `parseInt('2', 1)` 基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回`NaN`  
  `parseInt('3', 2)` 基数为2（2进制）表示的数中，最小值小于3，所以无法解析，返回`NaN`

7. 防抖和节流
    防抖——触发高频时间后n秒后函数只会执行一次，如果n秒内高频时间再次触发，则重新计时
  ```js
  function debounce(fn) {
    let timeout = null; // 创建一个标记来存放定时器的返回值
    
    return function() {
      clearTimeout(timeout); // 每当用户输入的时候 把前一个 setTimeout clear掉
      timeout = setTimeout(() => {
        // 然后又创建一个新的 setTimeout ,这样能够保证输入字符后的interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
        fn.apply(this, arguments)
      }, 500);      
    }
  }
  ```

  节流——高频时间触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率  
  ```js
  function throttle(fn) {
    let canRun = true // 通过闭包保存一个标记
    return function() {
      if(!canRun) return
      canRun = false // 立即设置为 false
      setTimeout(()=> {
        // 将外部传入的函数的执行放在setTimeout 中
        fn.apply(this, arguments)
        // 最后在 setTimeout 执行完毕后再把标记设置为 true（关键）表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return 掉
        canRun = true
      }, 500)
    }
  }
  ```

8. 介绍下Set、Map、WeakSet和WeakMap的区别
   答案：  
   - Set —— 对象允许存储任何类型的唯一值，无论是原始值或者是对象引用
   - WeakSet —— 成员都是都是对象：成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏；
   - Map —— 本质上是键值对的集合，类似集合；可以遍历，方法很多，可以跟各种数据格式转换。
   - WeakMap —— 只能接收对象作为键名（null除外），不接受其他类型的值作为键名；键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；不能遍历，方法有get、set、has、delete。

9. 深度优先遍历和广度优先遍历
    深度优先遍历 —— 是指从某个顶点出发，首先访问这个节点，然后找出刚访问这个节点的第一个未被访问的子结点，然后再以此子结点为顶点，继续找到它的下一个结点进行访问。重复此步骤，知道所有结点都被访问完为止；
    广度优先遍历 —— 是指从某个顶点出发，首先访问这个顶点，然后找到刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个字结点的所有结点，重复此方法，直到所有结点都被访问完为止。
  ```js
  // 1.深度优先遍历的递归写法
  function deepTraversal(node) {
    let nodes = []
    if(nodes != null) {
      let childrens = node.children
      for(let i = 0; i < childrens.length; i++) {
        deepTraversal(childrens[i])
      }
    }
    return nodes
  }

  // 2. 深度优先遍历的非递归写法
  function deepTraversal(node) {
    let nodes = []
    if(nodes != null) {
      let stack = [] // 用来存放将来要访问的节点
      stack.push(node)
      while(stack.length != 0) {
        let item = stack.pop() // 正在访问的节点
        nodes.push(item)
        let childrens = item.children
        for(let i = childrens.length - 1; i >= 0; i--) {
          stack.push(childrens[i]) // 将现在访问的节点的子节点存入stack，供将来访问
        }
      }
    }
    return nodes
  }

  // 3. 广度优先遍历的递归写法
  function wideTraversal(node) {
    let nodes = [],
        i = 0
    if(node != null) {
      nodes.push(node)
      wideTraversal(node.nextElementSibling)
      node = nodes[i++]
      wideTraversal(node.firstElementSibling)
    }
    return nodes
  }

  // 4. 广度优先遍历的非递归写法
  function wideTraversal(node) {
    let nodes = [],
        i = 0
    while(node != null) {
      nodes.push(node)
      node = nodes[i++]
      let childrens = node.children
      for(let i = 0; i < childrens.length; i++) {
        nodes.push(childrens[i])
      }
    }
    return nodes
  }
  ```

10. 输出是什么
  ```js
  (() => {
    let x,y
    try {
      throw new Error()
    } catch(x) {
      (x = 1), (y = 2)
      console.log(x)
    }
    console.log(x)
    console.log(y)
  })()
  ```
  答案：  
  `1 undefined 2`  
  解析：  
  `catch`代码块接收参数`x`。当我们传递参数时，这与之前定义的变量`x`不同，这个`x`属于`catch`块作用域。  
  然后，将块作用域中的变量`x`赋值为`1`，同时也设置了变量`y`的值。  
  `catch`块之外的变量`x`的值仍然为`undefined`，`y`的值为`2`。当在`catch`块之外执行`console.log(x)`时，返回`undefined`，`y`返回`2`。



11.ES5/ES6的继承除了写法以外还有什么区别？

1. ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到`this`上（`Parent.apply(this)`）

2. ES6的继承机制完全不同，实质上是先创建父类的实例对象`this`（所以必须先调用父类的`spuer()`方法），然后再用子类的构造函数修改`this`。

3. ES5的继承是通过原型或构造函数机制来实现。

4. ES6通过`class`关键字定义类，里面有构造方法，类之间通过`extends`关键字实现继承。

5. 子类必须在`constructor`方法中调用`super`方法，否则新建实例报错。因为子类没有自己的`this`对象，而是继承了父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类得不到`this`对象。

6. 注意：`super`关键字指代父类的实例，即父类的`this`对象。

7. 注意：在子类构造函数中，调用`super`后，才可使用`this关键字`，否则报错。

   ES5继承的实现（基于原型链）

   ```javascript
   // 创建一个 Human 构造函数
   function Human(name) {
       this.name = name
   }
   Human.prototype.run = function() {
       console.log('I can run')
   }
   
   // 创建一个 Man 构造函数
   function Man(name) {
       Human.call(this, name)
       this.gender = '男'
   }
   Man.prototype.fight = function () {
       console.log('I can finght')
   }
   
   // 让 Man 的原型对象的 proto 指向 Human 的原型对象
   Man.prototype.__proto__ = Human.prototype
   
   // 来 new 一个 Man 实例
   var Tony = new Man('Tony')
   console.log(Tony)
   ```

   ES6实现继承（class 和 extends）

   ```javascript
   class Human {
       constructor(name) {
           this.name = name
       }
       run() {
           console.log('I can run')
       }
   }
   
   class Man extends Human {
       constructor(name) {
           super(name)
            this.gender = '男'
       }
       fight() {
           console.log('I can finght')
       }
   }
   
   var Allen = new Man('Allen')
   console.log(Allen)
   ```

12. 异步笔试题，请写出下面代码的运行结果

    ```javascript
    async function async1() {
        console.log('async start');
        await async2();
        console.log('async end');
    }
    async function async2() {
        console.log('async2')
    }
    console.log('script start')
    setTimeouut(()=>{
        console.log('setTimeOut');
    }, 0);
    async1();
    new Promise(function (resolve) {
        console.log('promise1');
        resolve();
    }).then(function () {
      console.log('promise2'); 
    })
    console.log('script end');
    ```

    答案：

    ```javascript
    script start
    async1 start
    async2
    promise1
    script end
    async1 end
    promise2
    setTimeOut
    ```

    解析：

    1、执行`console.log('script start')`，输出`script start`；
    2、执行setTimeout，是一个异步动作，放入宏任务异步队列中；
    3、执行`async1()`，输出`async1 start`，继续向下执行；
    4、执行`async2()`，输出`async2`，并返回了一个promise对象，await让出了线程，把返回的promise加入了微任务异步队列，所以`async1()`下面的代码也要等待上面完成后继续执行;
    5、执行 `new Promise`，输出`promise1`，然后将`resolve`放入微任务异步队列；
    6、执行`console.log('script end')`，输出`script end`；
    7、到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务
    8、接下来执行`resolve（async2返回的promise返回的）`，输出了`async1 end`。
    9、然后执行`resolve（new Promise的）`，输出了`promise2`。
    10、最后执行`setTimeout`，输出了`settimeout`。

    ![](https://img-blog.csdnimg.cn/20190322161332450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9ob3U=,size_16,color_FFFFFF,t_70)

    补充：

    promise、async/await

    1. 首先，`new promise` 是同步任务，会被放到主线程中去立即执行。而 **`.then() `函数是异步任务**就会立即放到异步队列中。
2. 带`async`关键字的函数会返回一个`promise`对象，如果里面没有`await`，执行起来等于普通函数。
    3. `await`关键字要在`async`关键字函数的内部，`await`写在外面会报错；`await`会等待右侧的表达式完成。此时的 `await` 会让出线程，阻塞 `async` **内**后续的代码，先去执行 `async` 外的代码。等外面的同步代码执行完毕，才会执行里面后续的代码。就算 `await` 的不是 `promise` 对象，是一个同步函数，也会等这样操作。

9. 数组扁平化并去重

   ```javascript
   var arr = [[1,2,3],[3,4,5,5],[6,7,8,9,[11,12,[12,13,[14]]]],10];
   ```

   答案：

   ```javascript
   Array.from(new Set(arr.flat(Infinity))).sort((a, b) => { return a - b })
   ```



10. JS异步处理解决方案的发展历程以及优缺点

    1. 回调函数（`callback`）

       优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）

       缺点：回调地狱，不能用 `try catch` 捕获异常，不能 `return`

    2. Promise

       优点：解决了回调地狱的问题

       缺点：无法取消 `Promise` ，错误需要通过回调函数来捕获

    3. Generator

       特点：可以控制函数的执行，可以配合 `co` 函数库使用

    4. Async/Await

       优点：代码清晰，不用像 `Promise` 写一大堆 `then` 链，处理了回调地狱的问题

       缺点：`await` 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 `await` 会导致性能上的降低。



11. 简单讲一下http2的多路复用

    HTTP2采用二进制格式传输，取代HTTP1.x的文本格式，二进制格式解析更高效。

    多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。

    在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接的限制。

    HTTP2中，同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延时和内存消耗。

    单个连接上可以并行错误的请求和响应，之间互不干扰。

    