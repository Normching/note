1. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。  
  - A: 对
  - B: 错
  - C: 看情况

答案：A  

解析：基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。

****
2. 输出是什么？
   ```js
   const obj = { 1: 'a', 2: 'b', 3: 'c' }
   const set = new Set([1, 2, 3, 4, 5])

   obj.hasOwnProperty('1')
   obj.hasOwnProperty(1)
   set.has('1')
   set.has(1)
   ```
  - A：`false true false true`
  - B：`false true true true`
  - C：`true true false true`
  - D：`true true true true`

答案：C  

解析：所有对象的键（不包括symbol）在底层都是字符串，即使没有将其作为字符串输入。`obj.hasOwnProperty('1')`也返回`true`

对于集合，则不是。在集合中没有`'1'`，`set.has('1')`返回`true`。它的数字类型为`1`，`set.has(1)`返回`true`。

****
3. 输出是什么？
  ```js
  var num = 8;
  var num = 10;

  console.log(num);
  ```
  - A: 8
  - B: 10
  - C: SyntaxError
  - D: ReferenceError
  
  答案：B

  解析：使用 `var` 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。

****
4. 输出是什么？
  ```js
  function getPersonInfo(one, two, three) {
    console.log(one)
    console.log(two)
    console.log(three)
  }

  const person = 'Lydia'
  const age = 21

  getPersonInfo`${person} is ${age} years old`
  ```
  - A: "Lydia" 21 ["", " is ", " years old"]
  - B: ["", " is ", " years old"] "Lydia" 21
  - C: "Lydia" ["", " is ", " years old"] 21
  
  答案：B

  解析：如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值。

5. 输出是什么
   ```js
   const a = {}
   const b = { key: 'b' }
   const c = { key: 'c' }

   a[b] = 123
   a[c] = 456

   console.log(a[b])
   ```
   - A: 123
   - B: 456
   - C: undefined
   - D: ReferenceError
   
   答案：B

   解析：对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。
然而，当字符串化一个对象时，它会变成 `"[object Object]"`。因此这里说的是，`a["[object Object]"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a["[object Object]"] = 456`。
然后，我们打印 `a[b]`，也就是 `a["[object Object]"]`。之前刚设置为 `456`，因此返回的是 `456`。