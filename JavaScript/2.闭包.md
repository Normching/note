## 一、什么是闭包？
> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。——你不知道的JavaScript（上卷）

```js
function demo() {
  var a = 1;
  return function() {
    return a;
  }
}

var a = demo();
console.log(a()); // 1
```

### 1.闭包的构成
闭包由两部分构成：**函数，以及创建该函数的环境**。  
环境由闭包创建时在作用域中的任何局部变量组成。

### 2.闭包的本质
**闭包其实就是`JavaScript`函数作用域的副作用产品。**
**闭包是一种特殊的对象。**

在JavaScript中，外部函数调用之后其变量对象本应该被销毁，但闭包阻止了它们的销毁，我们仍然可以访问外部函数的变量对象。

通常情况下，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，如果创建了一个闭包的话，这个函数的作用域就会一直保存到闭包不存在为止。

```js
function addCalculator(x) {
  return function(y) {
    return x + y;
  }
}

var add1 = addCalculator(1);
console.log(add1(1)); // 2

// 释放对闭包的引用
add1 = null;
console.log(add1(1)); // Uncaught TypeError: add1 is not a function
```

### 3.闭包的应用
`Java`是支持私有方法的，私有方法只能被一个类中的其他方法调用，但是`JavaScript`没有提供这种原生支持，所以可以通过闭包来模拟私有方法。

私有方法自然有私有方法的好处，私有方法有利于限制对代码的访问，而且可以避免非核心的方法干扰代码的公共接口，减少全局污染。

```js
var calculator = (function() {
  var a = 1;
  function addCalculator(val) {
    a += val;
  }
  return {
    add1: function() {
      addCalculation(1);
    },
    add2: function() {
      addCalculation(2);
    },
    result: function() {
      return a
    }
  }
})();

console.log(calculator.result()); // 1
calculator.add1();
console.log(calculator.result()); // 2
calculator.add2();
console.log(calculator.result()); // 4
```
上面这种方式也叫做**模块模式（module pattern）**。



防抖、节流



### 4.使用闭包的注意事项
#### 内存泄漏
> 因为闭包可以使函数中的变量都保存在内存中，造成很大的内存消耗，所以如果不是某些特定的任务需要使用闭包，不要滥用它。

很多博客都提到了这一点，但是其实都是不完全对的。

使用不当的闭包会在`IE(IE9)`之前造成内存泄漏问题。因为它的`JavaScript`引擎使用的垃圾回收算法是引用计数法，对于循环引用将会导致`GC`无法回收垃圾。

[各个浏览器的闭包测试](https://www.cnblogs.com/rubylouvre/p/3345294.html)

## 二、垃圾回收机制
垃圾回收也就是`GC(Garbage Collection)`

`GC`把程序不用的内存空间视为垃圾，找到它们并且将它们回收，让程序员可以再次利用这部分空间。

> 不是所有的语言都有`GC`，一般存在于高级语言中，如`Java`、`JavaScript`、`Python`。那么在没有`GC`的世界里，程序员就比较辛苦，只能手动去管理内存，比如在`C`语言中可以通过`malloc/free`，在`C++`中的`new/delete`来进行管理。

## 三、垃圾回收算法
### 1.GC标记-清除算法
`GC标记-清除算法`由标记阶段和清除阶段构成，标记阶段将所有的活动对象做上相应的标记，清除阶段把那些没有标记的对象，也就是非活动对象进行回收。在搜索对象并进行标记的时候使用了深度优先搜索，尽可能的从深度上搜索树形结构。

优点：  
1. 算法简单，实现容易。
2. 与保守式的GC算法兼容。

缺点：  
1. 在使用过程中会出现碎片化，如同`Windows`的文件系统一样，导致无数的小分开散布在堆的各个地方。
2. 分配速度，由于分块的不连续性，算法每次分配的时候都需要遍历空闲链表为了找到足够大的分块，这样最糟糕的情况就是遍历到最后才找到合适的分块，影响了分配速度。

### 2.引用计数法
这种方法中引入了计数器的概念，通过计数器来表示对象被多少个程序引用了。当计数器（引用数）为0时，垃圾立刻被回收。

优点：  
1. 可以立即回收垃圾。
2. 最大暂停的时间短。
3. 并且没有必要沿指针查找。


缺点：  
1. 上文提到过的循环引用无法回收。
2. 并且实现起来很复杂。
3. 计数器的值增减处理十分繁重。
4. 同时计数器需要占很多位，导致内存空间的使用效率大大降低。
