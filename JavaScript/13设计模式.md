## 发布订阅模式

### 概念

发布——订阅模式又称观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。



### 优缺点

优点：一是时间上的解耦，二是对象之间的解耦

缺点：消耗一定的时间和内存



### 实现

#### 1.简单实现

```javascript
var event = {
    list: {},
    add(key, listener) {
        if (!this.list[key]) {
            this.list[key] = []
        }
        this.list[key].push(listener)
    },
    triggle(key) {
        this.list[key] && this.list[key].forEach(listener => {
            listener()
        })
    },
    remove(key, fn) {
        if (!this.list[key]) return
        var index = this.list[key].findIndex(listener => listener === fn)
        this.list[key].splice(index, 1)
    }
}

var f1 = () => { console.log('1') }
var f2 = () => { console.log('2') }
event.add('a', f1)
event.add('b', f2)

event.triggle('a')

event.remove('b', f2)
```



## 其他设计模式

### 1.创建型（帮助我们优雅地创建对象）

- 工厂模式：大量创建对象
  - 目的：方便大量创建对象
  - 应用场景：当某一个对象需要经常创建时
- 单例模式：全局只有一个实例
  - 目的：确保全局只有一个对象
  - 应用场景：为了避免重复新建，避免多个对象存在相互干扰
- 建造者模式：精细化组合对象
  - 目的：需要组合出一个全局对象
  - 应用场景：当要创建单个、庞大的组合对象时
- 原型模式

### 2.结构型（帮助我们优雅地设计代码结构）

- 外观模式
  - 目的：通过为多个复杂的子系统提供一个一致的接口
  - 应用场景：当完成一个操作时，需要操作多个子系统，不如提供一个更高级的
- 适配器模式：用适配代替更改
  - 目的：通过写一个适配器，来代替更改
  - 应用场景：应对接口不通用的问题
- 装饰者模式：扩展需求
  - 目的：不重写方法的扩展方法
  - 应用场景：当一个方法需要扩展时，但又不好去修改方法
- 享元模式：共享来减少数量
  - 目的：减少对象/代码数量
  - 应用场景：当代码中创建了大量类似对象和类似的代码块
- 桥接模式：独立出来，再对接过去
  - 目的：通过桥接代替耦合
  - 应用场景：减少模块之间的耦合

### 3.行为型（模块之间行为的模式总结，帮助我们组织模块行为）

- 观察者模式：作为第三方转发
  - 目的：减少对象间的耦合，来提高可扩展性
  - 应用场景：当两个模块直接沟通会增加它们的耦合性时
- 状态模式：用状态代替判断
  - 目的：优化if-else分支
  - 应用场景：当代码if-else分支过多时
- 策略模式：算法工程
- 职责链模式：像生产线一样组织模块
  - 目的：为了避免请求发送者与多个请求处理者耦合在一起，形成一个链条
  - 应用场景：把操作分隔成一系列模块，每个模块只处理自己的事情
- 命令模式：用命令去解耦
  - 目的：解耦实现和调用，让双方互不干扰
  - 应用场景：调用的命令充满不确定性
- 迭代器模式：告别for循环
  - 目的：不访问内部的情况下，方便的遍历数据
  - 应用场景：当我们需要对某个对象进行操作，但是又不能暴露内部

#### 4.技巧型（帮助我们优化代码的技巧）

- 链模式：链式调用
- 委托模式
- 数据访问模式：一个方便的数据管理器
- 惰性模式
- 等待者模式