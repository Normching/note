## 一、call
<span style="color: orangered">`call`和`apply`的区别：`call`方法接收的是一个参数列表，`apply`方法接收的是一个包含多个参数的数组。</span>

1. `context`存在就使用`context`，否则是`window`
2. 使用`Object(context)`将`context`转换成对象，并且通过`context.fn`将`this`指向`context`
3. 循环参数，注意从`1`开始，第`0`个是上下文，后面才是需要的参数
4. 将参数字符串`push`进`args`
5. 字符串和数组拼接时，数组会调用`toString`方法，这样可以实现将参数一个个传入，并通过`eval`执行
6. 拿到结果返回前，删除掉`fn`
```js
Function.prototype.call = function(context) {
  context = context ? Object(context) : window;
  context.fn = this;
  let args = [];
  for(let i = 1; i < arguments.length; i++) {
    args.push('arguments[' + i + ']')
  }
  let res = eval('context.fn(' + args + ')');
  delete context.fn;
  return res;
}
```

## 二、apply
1. `apply`无需循环参数列表，传入的`args`就是数组
2. 但是`agrs`是可选参数，如果不传入的话，直接执行
```js
Function.prototype.apply = function(context, args) {
  context = context ? Object(context) : window;
  context.fn = this;
  if(!args) {
    return context.fn();
  }
  let res = eval('context.fn('+ args +')');
  delete context.fn;
  return res;
}
```

## 三、bind
bind有一个特点：  
> 一个绑定函数也能使用`new`操作符创建对象：这种行为就像把原函数当成构造器。提供的`this`值被忽略，同时调用时的参数被提供给模拟函数。
也就是说，当`bind`返回的函数作为构造函数的时候，`bind`时指定的`this`值会失效，但传入的参数依然生效。

1. `bind`的参数可以在绑定和调用的时候分两次传入
2. `bindArgs`是绑定时除了第一个参数以外传入的参数，`args`是调用的时候传入的参数，将二者拼接后一起传入
3. 如果使用`new`运算符构造绑定函数，则会改变`this`指向，`this`指向当前的实例
4. 通过`Fn`链接原型，这样`fBound`就可以通过原型链访问父类`Fn`的属性
```js
Function.prototype.bind = function(context) {
  let that = this;
  let bindArgs = Array.prototype.slice.call(arguments, 1);
  function Fn() {};
  function fBound(params) {
    let args = Array.prototype.slice.call(arguments);
    // 当作为构造函数时，this指向实例，此时结果为ture，将绑定函数的this指向实例，可以让实例获得来自绑定函数的值
    // 当作为普通函数时，this指向window，此时结果为false，将绑定函数的this指向context
    return that.apply(this instanceof fBound ? this : context, bindArgs.concat(args));
  }
  // fBound.prototype = this.prototype;
  // 修改返回函数的 prototype 为绑定函数的 prototype ，实例就可以继承绑定函数的原型中的值
  // 但直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype
  // 可以通过一个空函数来进行中转
  Fn.prototype = this.prototype;
  fBound.prototype = new Fn();
  return fBound;
}
```

## 四、new
1. `Constructor`就是`new`时传入的第一个参数，剩余的`arguments`是其他的参数
2. 使用`obj.__proto__ = Constructor.prototype`继承原型上的方法
3. 将剩余的`arguments`传给`Contructor`，绑定`this`指向为`obj`，并执行
4. 如果构造函数返回的是引用类型，直接返回该引用类型，否则返回`obj`
```js
const myNew = function() {
  let Constructor = Array.prototype.shift.call(arguments);
  let obj = {};
  // obj 的原型指向构造函数，这样 obj 可以访问到构造函数原型中的属性
  obj.__proto__ = Constructor.prototype;
  // 改变构造函数 this 的指向到新创建的对象 obj ，这样 obj 就可以访问到构造函数中的属性
  let res = Contructor.apply(obj, arguments);
  return res instanceof Object ? res : obj;
}
```

## 五、instanceOf
1. 在`left`的原型链中层层查找，是否有原型等于`prototype`
2. 确定边界条件，如果`left === null`，即找到头都没找到返回`false`，`right === left`，即找到返回`true`
3. `left = left.__proto__`，不停的向上查找
```js
const myInstanceof = function(left, right) {
  right = right.prototype;
  left = left.__proto__;
  while(true) {
    if(left === null) {
      return false;
    }
    if(right === left) {
      return true;
    }
    left = left.__proto__;
  }
}
```

## 六、Object.create
- 新建一个空的构造函数`F`，然后让`F.prototype`指向`obj`，最后返回`F`的实例
```js
const myCreate = function(obj) {
  function F() {};
  F.prototype = obj;
  return new F();
}
```