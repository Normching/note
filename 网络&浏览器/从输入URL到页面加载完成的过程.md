1. 浏览器**查找域名对应的IP地址**

2. 1. 在浏览器地址栏输入URL（比如www.qq.com）后，操作系统先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
   2. 如果hosts里面没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
   3. 如果hosts和本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
   4. 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。
   5. 如果本地DNS服务器本地区域文件和缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，
      1. 如果未用转发模式，本地DNS就把请求发送至13台根DNS服务器，根DNS服务器收到请求后会判断这个域名（比如.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。
      2. 本地DNS服务器收到IP信息后，将联系负责该顶级域名服务器。这台负责该顶级域名的服务器收到请求后，如果自己无法解析，它就会找一个管理该顶级域名的下一级DNS服务器地址（比如qq.com）给本地DNS服务器。
      3. 当本地DNS服务器收到这个地址后，就会找该域服务器（qq.com域服务器），重复上面的动作，进行查询，直到找到该URL主机（www.qq.com）。
   6. 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把请求转发至上上级，以此循环。不管是本地DNS服务器转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

3. 浏览器根据IP地址与服务器**建立socket连接**

4. 1. 在发送HTTP请求前，需要域名解析（DNS解析），解析获取相应的IP地址

   2. 浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手

      1. 第一次握手：客户端将标志位SYN置为1，随机产生一个值为seq=X的数据包到服务器，客户端进入SYN_SENT状态，等待服务端确认；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）

      2. 第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置1，ack=X+1，随机产生一个值seq=Y，将该数据包发送给客户端已确认连接请求，服务端进入SYN_RCVD状态；（第二次握手，由服务端发起，告诉浏览器我准备接收了，你可以发送请求）

      3. 第三次握手：客户端收到确认后，检查ack是否为X+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=Y+1，并将该数据包发送给服务端，

         服务端检查ack是否为Y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务端进入ESTABLISHED状态，完成三次握手，

         随后客户端与服务端之间可以开始传输数据了（第三次握手，由浏览器发送，告诉服务器我马上发送请求，准备接收请求）

         ![](https://user-gold-cdn.xitu.io/2020/4/12/1716dfdccbdd0461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   3. 握手成功后，浏览器向服务器发送http请求，请求数据包

5. TCP连接建立后，浏览器与服务器通信：浏览器**发送HTTP请求**

6. 服务器**接受请求**并解析

7. 1. 服务器将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务器程序
   2. 服务器检查HTTP请求头是否包含**缓存验证信息**，如果缓存验证新鲜，返回304等对应状态码
   3. 处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作

8. 服务器将**响应**报文通过TCP连接发送回浏览器

9. 浏览器接收HTTP响应，然后根据情况选择**关闭TCP连接或者保留重用**，关闭TCP连接的四次挥手如下：

10. 1. 主动方发送FIN=1，ACK=Z，Seq=X报文

    2. 被动方发送ACK=X+1，Seq=Z报文

    3. 被动方发送FIN=1，ACK=X，Seq=Y报文

    4. 主动方发送ACK=Y，Seq=X报文

       ![](https://user-gold-cdn.xitu.io/2020/4/12/1716e7fa22920ea6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

11. 浏览器**检查响应状态码**：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同

12. 如果资源可**缓存**，进行缓存

13. 对相应进行**解码**（例如gzip压缩）

14. 根据资源类型决定如何处理（假设资源为HTML文档）

15. **解析HTML文档**

16. 1. 浏览器渲染引擎**构建DOM树**，使用HTML解析器解析HTML文档，将各个HTML元素逐个转化成DOM节点，从而生成DOM树。

    2. 1. Tokenizing：根据HTML规范将字符流解析为标记
       2. Lexing：词法分析将标记转换为对象并定义属性和规则
       3. DOM construction：根据HTML标记关系将对象组成DOM树

    3. 解析过程中遇到图片、样式表、JS文件，**启动下载**

    4. 浏览器渲染引擎**构建CSSOM树**，使用CSS解析器解析外部CSS文件以及HTML元素中的样式规则

    5. 1. Tokenizing：字符流解析为标记
       2. Node：根据标记创建节点
       3. CSSOM：节点创建CSSOM树

    6. 浏览器渲染引擎**构建渲染树**，使用CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

    7. 1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括
       
          1）script，meta这些本身不可见的标签.

          2）被CSS隐藏的节点，如display:none
       
       2. 对每个可见节点，找到恰当的CSSOM规则并应用
       
       3. 发布可视节点的内容和计算样式
       
    8. **解析JS**

    9. 1. 浏览器创建Document对象并解析HTML，将解析到的元素节点添加到文档中，此时document。`readystate`为`loading`
       2. HTML解析器遇到没有`async`和`defer`的script时，将它们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用`document.write()`把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，它们可以遍历和操作script和他们之前的文档内容
       3. 当解析器遇到设置了`async`属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用`document.write()`，它们可以访问自己的script和之前的文档元素
       4. 当文档元素完成解析，`document.readState`变成`interactive`
       5. 所有`defer`脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用`document.write()`
       6. 浏览器在Document对象上触发`DOMContentLoaded`事件
       7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件

    10. **布局渲染树**，渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。

    11. **绘制渲染树**，渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。

17. **页面显示**